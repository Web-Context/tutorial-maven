<h1>Maven? kesako ?</h1>
<p>Depuis que le monde java existe, il est continuellement accompagné de nombreux outils. Parmi ceux-ci, on compte les compilateurs (javac), les générateurs de documentation (javadoc), etc…</p>
<p>Il existe une autre catégorie d’outils: les outils d’aide à la construction.</p>
<p>Le plus ancien et le plus vénérable était <a href="http://ant.apache.org/">Ant</a>.  je dis était car il n’est plus trop au goût du jour. En effet, à sa suite sont arrivés bien des concurrents parmi lesquels on peut trouver, <a href="http://maven.apache.org/">maven</a>, <a href="http://www.gradle.org/">gradle</a> (Gradle, the next automation generation official web site), <a href="http://www.scala-sbt.org/">sbt</a> (Simple Build Tool, the Scala/Java official web site.) (pour Simple Build Tool), et la liste s’allonge tous les jours.</p>
<p>Celui qui a le plus marqué ces 10 dernières années et qui domine encore le marché de la construction d’application, car utilisé de façon industrielle est Maven.</p>
<p>Maven va au delà du simple outil de construction, il possède un cycle de vie qui colle à celui de la fabrication d’un logiciel. La simple commande <code>mvn</code> est capable, dans le désordre:</p>
<ul>
<li>de compiler,</li>
<li>de gérer les dépendances de version de composants,</li>
<li>d’exécuter des tests unitaires(UT),</li>
<li>des tests  d’intégration (INT),</li>
<li>et des test End-to-End (E2E).</li>
</ul>
<p>Elle est même capable de prendre en main la création d’une release, se chargeant de la gestion du numéro de version, de la compilation des dépendances, et du packaging dans le but de la livraison, sous plusieurs formes pilotées qui plus est: JAR, WAR et/ou EAR. il sera même capable de construire la documentation du code basée sur javadoc ou même docbook, de construire un site de livraison et même, si vous lui demandez avec les formes,  proposera un packaging en ZIP des sources du projet.</p>
<p>Bref, vous le comprenez, Maven est L’outil du jour pour la construction de logiciel Java.</p>
<p>Même si quelques concurrent arrivent doucement à sa hauteur, comme graddle, aujourd’hui seul maven est capable de couvrir un tel gamme de prestation.</p>
<h1>Premier shoot à la pom(.xml)</h1>
<p>Il est intéressant d’observer de plus près la constitution de ce fichier, il constitue la recette de fabrication de votre application. on y trouvera les nom, description et version de votre logiciel, mais aussi, ses dépendances avec le monde extérieur, ainsi que la recette de fabrication permettant d’aller du fichier source (<strong>.java de façon générale) vers le JAR, le WAR ou même l’EAR.
<br />h2. JAR? WAR ? EAR ?
<br />Quels sont ces acronymes barbares ? Quelques rappels s’imposent:
<br /></strong> <strong>JAR</strong> : Java ARchive, c’est le packaging de base de la livraison d’un quelconque logiciel ou partie de logicel basé sur le langage java. On pourra trouvé en son sein des classes java compilée (.class), des fichiers de resources divers (.xml, .properties, .txt, etc…) et aussi et surtout la classe contenant si besoin le fameux main() pour la lancement de votre programme, dans le cas d’un logiciel autonome. Le JAR peut (et c’est souvent le cas) contenir une API (Application Programming Interface) constituant les points d’entrées d’une librairie apportant nombre de fonctionalité. Les plus connues dans le monde java sont log4j, ainsi que les apache-commons.<br />* <strong>WAR</strong> : Web ARchive: c’est le cran au dessus du JAR, on trouvera comme dans les jar, des classes java, des resources, mais aussi et surtout une structure adapté au service d’applications orientée web. on pourra trouver des répertoires specifique au web tels que WEB-INF/ et META-INF/ contenant eux-mêmes des fichiers de configuration à destination du serveur Java qui sera chargé lors du déploiement de servir l’application sur internet ou l’intranet d’une entreprise.<br />* <strong>EAR</strong> Enterprise AR, ce type d’archive est destinée à contenir un ensemble de services ou d’applications qui sont elles-mêmes packagées au format WAR. C’est une commodité de déploiement. Elle contiendra également des informations de contexte destinée au serveur, et permettant de lui expliquer les liens entre les différentes applications et services qu’elle contient.</p>
<p>Pourquoi ce rappel ? Parce que justement, le petit fichier Project Maven, le fameux <code>pom.xml</code>, permet de préciser, entre autres, la cible de packaging de votre projet.</p>
<p>La structure du fichier obéit a quelques règles syntaxiques de base. Vous trouverez ci-dessous un modèle de fichier type.</p>
<p>bc(java). <project xmlns="http://maven.apache.org/POM/4.0.0" 
  xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" 
  xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd"><br /> <modelVersion>4.0.0</modelVersion><br /> <groupId>[project_group_id]</groupId><br /> <artifactId>[project_articfact_id]</artifactId><br /> <version>[project_version: ex. : 0.0.1-SNAPSHOT]</version><br /> <packaging>[jar/war/ear/pom]</packaging><br /> <name>[project_name]</name><br /> <description>[project_description]</description><br /></project></p>
<p>Voila comment se décrit un projet à l’aide de Maven.</p>
<p>En exemple, attaché à cet article, vous trouvez dans ce fichier <code>pom_sample.xml</code> décrivant une application web orientée REST, plus d’information sur les possibilités d’un “simple pom” au niveau de la description administrative du projet. L’intérêt ne sera que visible lors de la mise en intégration continue (ou construction continue), où les liens vers le repository de sources ou l’outil de suivi des bugs auront tous leurs sens.</p>
<p>Atardons nous sur les principaux champs de ce <code>pom.xml</code>:</p>
<p><code>[project_group_id]</code> et <code>[project_artifact_id]</code> sont les premiers piliers de Maven, ils vont permettre d’identifier clairement votre projet. Dans le cas ou ce projet ne serait qu’une partie d’une application impliquant plusieurs composant, accompagné du tag de version (<code>[project_version]</code>) va permettre une gestion fine des dépendances.</p>
<p>C’est la première mission de maven.</p>
<p>Un projet réalisé sous maven, est en fait dénommé un artifact, il possède son propre identifiant, l’artifactId. Ce projet fait obligatoirement partie d’un groupe, cela permettant un classement des composants d’un même projet, ou d’un ensemble de projets. Il est par habitude composé principalement du nom de la société, de l’association, de la fondation ou de l’organisation à l’origine du logiciel. dans notre cas, nous partirons sur com.webcontext.apps pour tous nos exemples dans la suite de cet article. Le groupe en question sera également identifié par un groupId.</p>
<blockquote>
<p><strong>Note</strong><br />Le groupId est souvent similaire au nom du package java de base de votre application. par exemple si votre application est contenu par un package de base “com.masociete.monprojet”, le groupId pourra être “com.masociete.apps” et l’artifactId “monrpojet”.</p>
</blockquote>
<h2>BUILD</h2>
<p>La deuxième mission de maven est l’aide à la construction de l’application. le premier élement a spécifier serait donc une cible de compilation. Implicitement, maven nécessite la présence d’un JDK afin de pouvoir compiler les sources java. Maven n’apportant pas lui-même ces outils de base. Aussi, vous devez, par maven, indiquer une cible de version de ce JDK.</p>
<p>cela se fera via l’aide d’un ensemble de plugin de maven, spécialisés sur certaines missions.</p>
<p>Attardons nous un peu sur le premier :</p>
<table>
<tbody>
<tr class="odd">
<td align="left">_ Attribut</td>
<td align="left">_ Valeur</td>
</tr>
<tr class="even">
<td align="left">groupId</td>
<td align="left">org.apache.maven.plugins</td>
</tr>
<tr class="odd">
<td align="left">artifactId</td>
<td align="left">maven-compiler-plugin</td>
</tr>
<tr class="even">
<td align="left">version</td>
<td align="left">3.1</td>
</tr>
</tbody>
</table>
<p>Et oui, même les plugins sont gérés et identifiés par Maven.</p>
<p>Déclarons dans le fichier pom.xml que nous souhaitons utiliser un compilateur issu de la version 1.7 de java:</p>
<p>bc(xml). <build><br /> <plugins><br /> <plugin><br /> <groupId>org.apache.maven.plugins</groupId><br /> <artifactId>maven-compiler-plugin</artifactId><br /> <version>3.1</version><br /> <configuration><br /> <target>1.7</target><br /> <source>1.7</source><br /> <encoding>UTF-8</encoding><br /> </configuration><br /> </plugin><br /> </plugins><br /></build></p>
<p>C’est simple, net et précis. l’opération de build doit s’appuyer sur a configuration de compilation indiquant une version 1.7 du JDK pour le compilateur.</p>
<p>Nous spécifions également l’encodage des fichiers, que nous fixons ici à “UTF-8”, cela pour des raisons évidentes de compatibilité cross-plateforme.</p>
<p>Maintenant, si nous exécutons notre premier commande maven via la commande <code>mvn</code>, nous pourrons lancer l’une ou l’autre des étapes de construction de notre application, appelées dans le jargon maven, des goals.</p>
<p>Les deux premiers qui nous intéressent pour le moment sont “<code>clean</code>” et “<code>build</code>”.</p>
<ul>
<li><strong>clean</strong> : permet de nettoyer l’espace de travail de toute ancienne trace de compilation, ce afin de partir sur des base seine pour la nouvelle compilation. Notons en passant que un nouveau répertoire va faire son apparition à l’exécution de cette première commande, <code>target</code>. c’est dans ce répertoire que seront construit tous les éléments de notre projet pour préparer plus tard le packaging en JAR, WAR ou EAR.</li>
<li><strong>compile</strong> : c’est l’opération de compilation faisant appel au compilateur java dans la version de compatibilité indiquée (ici 1.7). javac sera lancé par maven avec toutes les options nécessaires pour atteindre ce but.</li>
</ul>
<h3>Compilation</h3>
<p>Lançons nous :</p>
<p>bc(console). $ mvn clean<br />$ mvn compile</p>
<p>Nous avons doc nettoyé et compilé nos sources. Enfin, pour le moment, cela est fictif car nous n’avons pas encore de sources. D’ailleurs a ce propos, regardons la structure d’un projet maven:</p>
<p>bc(diagram). _ [mon_projet] # repertoire de base du projet<br /> |_ src # sources du projet découpées en deux groupes<br /> | |_ main # les sources a proprement parlé du code du projet<br /> | | |_ java # - les classes java dans leurs packages <br /> | | |_ resources # - les resources additionnelles comme les <strong>.properties,</strong>.xml, …<br /> | | |_ webapp # - les fichiers composant les UI (html, css, images, javascript)<br /> | |_ test # le code des tests unitaires, intégration et E2E.<br /> | | |_ java # - les parties java pour l’exécution de ce tests<br /> | | |_ resources # - les éventuelles ressources nécessaires (données de test)<br /> |_ target # l’espace réservé à la compilation et au packaging<br /> |_ pom.xml # le fichier de description du projet maven.</p>
<p>Voila en quelques lignes décrite la structure standard d’un projet Maven.</p>
<p>Il nous reste a créer un premier vrai projet. je vous propose la réalisation d’un projet Web basé sur une mise en oeuvre de la Technologie REST propre à java, JAX-RS décrit dans la spécification standard <a href="https://jsr311.java.net/">JSR-311</a> (Spécification officiel JSR-311 de la technologie Java RESTful).</p>
<p>Mais en premier lieu, il nous faudra comprendre le fonctionnement de base sur un projet simple, à base de JAR.</p>
<p>La suite au prochain numéro.</p>
<p><em>To be continued… _
<br />h1. Dans le gras du sujet
<br />p. Il faut bien avouer que le premier article était TRES succinct. Je vous propose d’aborder plus sérieusement le sujet.

<br />h2. Gooooooaaal !
<br />p. Commençons par le début: les “goals”  J’ai évoqué dans la première partie le fait que Maven couvrait toutes les phases de la production logicielle. Et bien c’est exactement le cas.
<br />p. Illustrons “:http://www.amazon.com/gp/product/0596517335 , je l’avoue) l’exemple d’un projet java consistant à créer une librairie livrable sous forme de jar.
<br />p. Commençons par le début, appelons notre librairie ZeLibraire, publiée par moi même et qui, malencontreusement ne sert a rien d’autre que d’être un exemple par pour cette série d’article. Nous allons donc produire un beau logiciel à l’aide de maven. pour cela, nous devrons, compiler, gérer des dépendances, faire des tests (par là comprenons les jouer en automatique) et enfin, si tout cela fonctionne, nous pourrons le packager sous la forme d’un JAR.
<br />p. Ensuite nous verrons que, afin de livrer cette librairie de façon propre et élégante, nous pourrons assemble sources, documentation et jar de façon très propre (limite professionnel oserais-je, et cela tombe bien, c’est à cela que Maven sert).
<br />p. Voila un premier schéma (chouette hein ?) qui explique les principales phases que nous allons activer pour notre projet Zelibrairie.
<br />”<embed src="http://mcgivrer.files.wordpress.com/2014/04/maven-phases-vs-goals.png?w=750" />“:http://mcgivrer.files.wordpress.com/2014/04/maven-phases-vs-goals.png
<br />p(figure). Phases et goals de Apache Maven
<br />p. Bon, un peu d’explication:
<br />p. sur la gauche, en <span style="color: blue; font-weight: bold;">bleu</span>, les phases gérées par Maven, sur la droite, en <span style="color: green; font-weight: bold;">vert</span> les”Goals&quot; activables correspondants. 
<br />p. Ok, nous voilà bien avancés, nous ne savons toujours pas ce qu’est un “goal”.
<br />p. Un <strong>goal</strong> est en fait une action que l’on peut lancer depuis la commande <code>mvn</code>.  . Par exemple, pour nettoyer l’espace de compilation, nous ferons :

<br />bc.. $ mvn clean
<br />p. Nous commençons maintenant à entrevoir quelques possibilités offertes par Maven.

<br />h2. A l’attaque des pom’s
<br />p. Si je veux commencer à créer mon projet , voilà à quoi ressemble les premières lignes de mon fichier de projet maven: file: <strong>pom.xml</strong>

<br />bc. <project xmlns="http://maven.apache.org/POM/4.0.0" 
xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" 
xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 
http://maven.apache.org/xsd/maven-4.0.0.xsd"><br /><modelVersion>4.0.0</modelVersion><br /><groupId>com.webcontext.apps</groupId><br /><artifactId>zelibrairie</artifactId><br /><version>0.0.1-SNAPSHOT</version><br /><packaging>jar</packaging><br /><name>ZeLibrairie</name><br /><description>A demonstration librabry project to illustrate <br />apache maven usage. </description><br /><url>http://www.github.com/web-context/zelibrairie</url><br /><organization><br /><name>WebContext</name><br /><url>http://www.web-context.com/</url><br /></organization><br /></project>
<br />p. Nous avons maintenant indiqué que le projet s’appellerait <code>Zelibrairie</code>, que le nom maven du projet serait@zelibrairie@ , qu’il serait publié sous le groupe <code>com.webcontext.apps</code> . On trouve également une <code>version</code> du logiciel qui servira à suivre la vie du dit logiciel. on trouve également des champs <code>description</code> et <code>organisation</code> qui serviront à documenter le projet lorsque celui-ci sera publié sur un dépôt officiel Maven .


<br />h2. Super Structure
<br />p. Nous n’avons pas encore expliqué la structure d’un projet dansles détails. Afin de l’illustrer, commençons par créer notre répertoire de travail :

<br />bc.. $ mkdir zelibrairie$ cd zelibrairie
<br />p. Ensuite, créons la structure du projet:
<br />bc.. $ mkdir <del>p zelibrairie/src/main/java<br />$ mkdir</del>p zelibrairie/src/test/java
<br />p. A l’aide de notre éditeur de code préféré, créons le fichier <code>pom.xml</code> en copiant le contenu de l’exemple précédemment indiqué. Nous obtenons la structure ci-dessous:
<br />bc.. zelibrairie # répertoire de base du projet<br />|</em> src # sources du projet découpées en deux groupes<br />| |_ main # les sources a proprement parlé du code du projet<br />| | |_ java # - les classes java dans leurs packages<br />| |_ test # le code des tests unitaires, intégration et E2E.<br />| | |_ java # - les parties java pour l’exécution de ce tests<br />|_ pom.xml # le fichier de description du projet Maven.</p>
<p>Structure des sources d’un projet “Mavenisé”</p>
<h2>Léon le nettoyeur</h2>
<p>Executons maintenant la commande d’exécution du goal <code>clean</code></p>
<p>Sur la console, nous pourons lire:</p>
<p>bc(console).. $ mvn clean<br />[INFO] Scanning for projects…<br />[INFO] <br />[INFO] ————————————————————————<br />[INFO] Building ZeLibraibrie 0.0.1-SNAPSHOT<br />[INFO] ————————————————————————<br />[INFO] <br />[INFO] — maven-clean-plugin:2.5:clean (default-clean) @ zelibrairie —<br />[INFO] ————————————————————————<br />[INFO] BUILD SUCCESS<br />[INFO] ————————————————————————<br />[INFO] Total time: 0.299s<br />[INFO] Finished at: Mon Apr 14 01:42:37 CEST 2014<br />[INFO] Final Memory: 5M/108M<br />[INFO] ————————————————————————</p>
<p>Un répertoire <code>target</code> sera créé dès que nous exécuterons la commande de compilation; c’est là que le résultat du travail sera produit.</p>
<h3>Compilator, le retour</h3>
<p>Même sans code, vous pouvez lancer une petite compilation :</p>
<p>bc(console).. $ mvn compile</p>
<p>donnant lieu à la sortie console suivante :</p>
<p>bc(console).. $ mvn compile<br />[INFO] Scanning for projects…<br />[INFO]<br />[INFO] ————————————————————————<br />[INFO] Building ZeLibrairie 0.0.1-SNAPSHOT<br />[INFO] ————————————————————————<br />Downloading: http://repo.maven.apache.org/maven2/org/apache/maven/plugins/maven-<br />resources-plugin/2.5/maven-resources-plugin-2.5.pom<br />…<br />…<br />Downloaded: http://repo.maven.apache.org/maven2/org/codehaus/plexus/plexus-compi<br />ler-javac/1.8.1/plexus-compiler-javac-1.8.1.jar (13 KB at 26.8 KB/sec)<br />[INFO] Nothing to compile - all classes are up to date<br />[INFO] ————————————————————————<br />[INFO] BUILD SUCCESS<br />[INFO] ————————————————————————<br />[INFO] Total time: 8.715s<br />[INFO] Finished at: Mon Apr 14 10:52:35 CEST 2014<br />[INFO] Final Memory: 6M/244M<br />[INFO] ————————————————————————</p>
<p>Mais comment se fait-il que la compilation d’aucun code produise autant de choses ? :) Et bien, cela vient du fait de la nature même de Maven, qui est constitué uniquement d’un système de plugins.</p>
<p>Ces plugins sont activés sur certaines phases du cycle Maven, et s’ils ne sont pas disponibles localement (dans un répertoire de cache <code>[USERHOME]/.m2/repository</code>), ils sont automatiquement téléchargés, et activés.</p>
<p>En lançant pour la premier fois la compilation de notre projet, c’est ce qu’il vient de se passer. Dans le log des opérations, nous pouvons constater, entre autres, le téléchargement d’un plugin du nom de <code>plexus-compiler-javac-1.8.1.jar</code>: c’est le moteur de compilation de Maven pour les fichiers sources<br />java.</p>
<p>nous pouvons finalement voir que notre compilation à réussi (le contraire eu été inquiétant :)</p>
<p>Ok, ajoutons un peu de code pour voir de quoi Maven est capable !</p>
<h2>Les choses sérieuses</h2>
<p>La structure d’un pom est très importante et elle donne moulte information sur un projet, non seulement à l’outil Maven, mais aux développeurs.</p>
<p>Reprenons le <code>pom.xml</code> standard et regardons de plus près les différents blocs:</p>
<p>p=. <a href="http://mcgivrer.files.wordpress.com/2014/04/maven-pom-xml-full-structure-overview.png"><img src="http://mcgivrer.files.wordpress.com/2014/04/maven-pom-xml-full-structure-overview.png" alt="" />(Les différents blocs dans le fichier pom.xml de Maven.)</a></p>
<p>p=(figure). Les différents blocs dans le fichier pom.xml de Maven.</p>
<p>Après avoir découvert ensemble la partie déclaration administrative, nous devons voir de plus près la partie <strong>dependencies</strong>.<br />Les “dependencies” sont la déclaration des librairies nécessaires à l’exécution de votre programme. Ces dépendances se retrouveront sur le “chemin de classe” (oui, c’est curieux, le classpath en français). et en fonction du paramètre <code>scope</code>, la librairie sera présente dans le classpath de compilation, de test, ou de runtime.</p>
<p>Il est également possible de d&amp;clarer des dépendances dites “systèmes”, elles seront packagée dans l’application finale,non pas depuis le repository (que nous découvrirons et expliquerons plus tard) mais depuis un chemin fixe, par exemple <code>c:\meslibrairies\monjar.jar</code>.</p>
<h3>les différents scopes</h3>
<table>
<thead>
<tr class="header">
<th align="left">Scope</th>
<th align="left">Description</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td align="left"><code>compile</code></td>
<td align="left">La dépendance sera ajoutée au classpath dans tous les cas</td>
<td align="left"></td>
<td align="left"><code>runtime</code></td>
<td align="left">la dépendance sera package avec l’application mais n’est pas nécessaire à la compilation.</td>
<td align="left"></td>
<td align="left"><code>test</code></td>
<td align="left">cette fois, la dépendance sera présente uniquement lors de la phase d’execution des tests (voir le graphe plu haut pour revoir les phases/goals de maven</td>
<td align="left"></td>
<td align="left"><code>system</code></td>
<td align="left">La dépendance système a la particularité</td>
<td align="left"></td>
<td align="left"><code>provided</code></td>
<td align="left">La dépendance est intégrée au classpath pour la compilation mais ne sera pas packagée car réputée fournie par l’environnement d’execution de l’application, le conteneur web dans le cas d’une application, par exemple.</td>
<td align="left"></td>
<td align="left"><code>import</code></td>
<td align="left">ce scope n’est disponible que pour une dépendance de type <code>pom</code>. l’ensemble des dépendances mentionnées dans le pom référencé comme dépendances seront portées au classpath et packagée dans l’application.</td>
</tr>
</tbody>
</table>
<p>Les différents scopes maven.</p>
<p>Nous disions vouloir construire une premier application, donc ? non ?</p>
<p>Ajoutons les dépendances de base nécessaire à notre petite code party: à savoir l’indispensable logger <code>Log4J</code>, ainsi que le non moins indispensable <code>JUnit</code> ce qui nous permettra de jouer avec les fameux scopes et permettra de mieux comprendre leur intérêt. Donc, éditons notre fichier POM pour ajouter les dites dépendances:</p>
<p>bc(xml).. <project><br /> …<br /> <groupId></groupId><br /> <artifactId></artifactId><br /> <version></version><br /> …<br /> <dependencies></p>
<p></p>
<!-- logging capability -->
<p><dependency><br /> <groupId>log4j</groupId><br /> <artifactId>log4j</artifactId><br /> <version>1.2.17</version><br /> </dependency></p>
<p></p>
<!-- testing capability -->
<p><dependency><br /> <groupId>junit</groupId><br /> <artifactId>junit</artifactId><br /> <version>4.11</version><br /> <scope>test</scope><br /> </dependency></p>
<p></dependencies><br /> …<br /> </project></p>
<h3>Configuración del Compilador</h3>
<p>Ensuite concentrons nous sur la compilation. Nousouhaitons préciser que l’application doit être compilée sur un JDK 1.7 et que nous voulons nous assurer que les sources soient bien encodés en UTF-8: c’est le plugin maven special <code>maven-compiler-plugin</code> qui a la charcge de vérifier et activer cela:</p>
<p>bc(xml). <build><br /> <plugins><br /> <plugin><br /> <groupId>org.apache.maven.plugins</groupId><br /> <artifactId>maven-compiler-plugin</artifactId><br /> <version>3.1</version><br /> <configuration><br /> <target>${src.target}</target><br /> <source>${src.source}</source><br /> <encoding>${src.encoding}</encoding><br /> </configuration><br /> </plugin><br /> </plugins><br /></build></p>
<p>Nous utilisons ici une version 3.1 du plugin. nous précisons l’encodage des fichiers et le JDK à utiliser.</p>
<h3>Application à 2 classes</h3>
<p>OK, créons une ou deux classes (en fait deux) dans le répertoire <code>src/main/java</code> en respectant biensur le chemin de package <code>com.webcontext.libs.zelibrairie</code> pour pouvoir faire quelques tests depuis l’autre répertoire <code>src/test/java</code>: nota: les classes ont été volontairemetn simplifiées dans l’article et sont bien complète sur le repository github (<a href="http://github.com/Web-Context/tutorial-maven&quot;">http://github.com/Web-Context/tutorial-maven</a> )</p>
<p><strong>1.</strong> Une entité digne de ce nom pour modélisé un User (oh c’est super original, je sais) :</p>
<p><strong>file:</strong> <code>com.webcontext.libs.zelibrairie.model.User(.java)</code></p>
<p>bc(java).. public class User{<br /> public String username;<br /> public String lastname;<br /> public String firstname;<br /> public String email;<br /> public String password;</p>
<p>public User(){</p>
<p>}</p>
<p>/<strong>—- getters &amp;amp; setters —-</strong>/<br /> …</p>
<p><code>Override
  public String toString() {
    StringBuilder builder = new StringBuilder();
    builder.append(&quot;User [&quot;);
    if (username != null)
    builder.append(&quot;username=&quot;).append(username).append(&quot;, &quot;);
    if (email != null)
    builder.append(&quot;email=&quot;).append(email).append(&quot;, &quot;);
    if (firstname != null)
    builder.append(&quot;firstname=&quot;).append(firstname).append(&quot;, &quot;);
    if (lastname != null)
    builder.append(&quot;lastname=&quot;).append(lastname);
    builder.append(&quot;]&quot;);
    return builder.toString();
  }
}

p. *2.* Un service de gestion de ces utilisateurs :

p. *file:* </code>com.webcontext.libs.zelibrairie.services.UserService(.java)@</p>
<p>bc(java).. public class UserService {<br /> private static Map<String , User> users = new HashMap<String, User>();</p>
<p>public User add(User user) {<br /> users.put(user.getUsername(), user);<br /> return user;<br /> }</p>
<p>public void add(Collection<User> newUsers) {<br /> for (User user : newUsers) {<br /> users.put(user.getUsername(), user);<br /> }<br /> }</p>
<p>public User update(User user) {<br /> users.put(user.getUsername(), user);<br /> return user;<br /> }</p>
<p>public User delete(User user) {<br /> users.remove(user.getUsername());<br /> return user;<br /> }</p>
<p>public User findByUsername(String username) {<br /> return users.get(username);<br /> }</p>
<p>public List<User> findAll() {<br /> List<User> rtusers = (List<User>) users.values();<br /> return rtusers;<br /> }</p>
<p>public int count() {<br /> return users.size();<br /> }</p>
<p>}</p>
<h3>Testator 2: The Revenge</h3>
<p>Nos classes applicatives étant prêtes, nous allons nous pencher sur notre classe de test du service <code>UserService</code>, dans le répertoir <code>src/test/java</code>, donc:</p>
<p><strong>file:</strong> <code>com.webcontext.test.unit.libs.zelibrairie.services.UserService(.java)</code></p>
<p>bc(java).. <code>FixMethodOrder(MethodSorters.NAME_ASCENDING)
public class UserServiceTest {

  private static Map&lt;String , User&gt; userstest = new HashMap&lt;String, User&gt;();
  private static UserService userService = new UserService();

  </code>Before<br /> public void setUp() throws Exception {<br /> userService = new UserService();<br /> userstest = new HashMap<String , User>();<br /> // add some user<br /> userstest.put(“user1”, new User(“user1”, “User”, “User1”,<br /> “user1@mail.com”, “password”));<br /> userstest.put(“user2”, new User(“user2”, “User”, “User2”,<br /> “user2@mail.com”, “password”));<br /> userstest.put(“user3”, new User(“user3”, “User”, “User3”,<br /> “user3@mail.com”, “password”));<br /> userstest.put(“user4”, new User(“user4”, “User”, “User4”,<br /> “user4@mail.com”, “password”));<br /> }</p>
<p><code>After
  public void tearDown() throws Exception {
    userService = null;
    userstest = null;
  }

  </code>Test<br /> public void test_1_add() {<br /> User usernew = new User(“usernew”, “Usernew”, “Newuser”,<br /> “new.user@mail.com”, “password”);<br /> userService.add(usernew);<br /> assertEquals(“Size of collection is not the right one.”, 1,<br /> userService.count());<br /> }</p>
<p><code>Test
  public void test_2_AddListUserandFindByUsername() {
    userService.add(userstest.values());
    assertEquals(&quot;All users was not inserted !&quot;, 5, userService.count());

    User user1 = userService.findByUsername(&quot;user1&quot;);
    assertTrue(&quot;User not found&quot;, user1!=null);
    assertEquals(&quot;User not the right one.&quot;, &quot;User1&quot;, user1.getLastname());
  }

  </code>Test<br /> public void test_3_AddListUserAndDelete() {<br /> userService.add(userstest.values());</p>
<p>User user1 = userService.findByUsername(“user1”);<br /> userService.delete(user1);<br /> User isUserDeleted = userService.findByUsername(“user1”);<br /> assertTrue(“User has not bean deleted”, isUserDeleted==null);<br /> }<br /> <code>Test
  public void test_4_update() {
    User usernew = new User(&quot;usernew&quot;, &quot;Usernew&quot;, &quot;Newuser&quot;,
    &quot;new.user</code>mail.com“,”password“);<br /> userService.add(usernew);<br /> User last = userService.findByUsername(”usernew“);<br /> last.setFirstname(”Toto“);<br /> User modified = userService.update(last);
<br /> assertEquals(”USer was not modified“,”Toto“,modified.getFirstname());<br /> }<br />}
<br />bq(info).. <strong>Trick &amp;amp; Tips</strong><br/><br />Noter l’annotation en amont de déclaration de la classe <code>@FixMethodOrder</code> qui permet d’imposer à JUnit (depuis la version 4.11), un ordre d’exécution des différentes méthodes annotées <code>@Test</code>.
<br /><code>MethodSorters.NAME_ASCENDING</code> propose une exécution dans l’ordre alphabétique des nom des méthodes.
<br />h2. Test test test !
<br />p. Maintenant, ne faiblissons pas, compilons et testons
<br />bc(console).. $ mvn clean test
<br />p. En laçant cette commande, maven nettoie le projet, et compile tous les sources, en scope <code>compile</code> et <code>test</code>. Enfin, les tests JUnit présents sont exécutés :
<br />bc(console).. [INFO] Scanning for projects…<br />[INFO] <br />[INFO] ————————————————————————<br />[INFO] Building ZeLibrairie 0.0.1-SNAPSHOT<br />[INFO] ————————————————————————<br />[INFO] <br />[INFO] — maven-clean-plugin:2.5:clean (default-clean) @ zelibrairie —<br />[INFO] Deleting /home/frederic/Projects/tutorials/tutorial-maven/samples/zelibrairie/target<br />[INFO] <br />[INFO] — maven-resources-plugin:2.6:resources (default-resources) @ zelibrairie —<br />[WARNING] Using platform encoding (UTF-8 actually) to copy filtered resources, i.e. build is platform dependent!<br />[INFO] skip non existing resourceDirectory /home/frederic/Projects/tutorials/tutorial-maven/samples/zelibrairie/src/main/resources<br />[INFO] <br />[INFO] — maven-compiler-plugin:3.1:compile (default-compile) @ zelibrairie —<br />[INFO] Changes detected - recompiling the module!<br />[WARNING] File encoding has not been set, using platform encoding UTF-8, i.e. build is platform dependent!<br />[INFO] Compiling 2 source files to /home/frederic/Projects/tutorials/tutorial-maven/samples/zelibrairie/target/classes<br />[INFO] <br />[INFO] — maven-resources-plugin:2.6:testResources (default-testResources) @ zelibrairie —<br />[WARNING] Using platform encoding (UTF-8 actually) to copy filtered resources, i.e. build is platform dependent!<br />[INFO] skip non existing resourceDirectory /home/frederic/Projects/tutorials/tutorial-maven/samples/zelibrairie/src/test/resources<br />[INFO] <br />[INFO] — maven-compiler-plugin:3.1:testCompile (default-testCompile) @ zelibrairie —<br />[INFO] Changes detected - recompiling the module!<br />[WARNING] File encoding has not been set, using platform encoding UTF-8, i.e. build is platform dependent!<br />[INFO] Compiling 1 source file to /home/frederic/Projects/tutorials/tutorial-maven/samples/zelibrairie/target/test-classes<br />[INFO] <br />[INFO] — maven-surefire-plugin:2.12.4:test (default-test) @ zelibrairie —<br />[INFO] Surefire report directory: /home/frederic/Projects/tutorials/tutorial-maven/samples/zelibrairie/target/surefire-reports
<br />——————————————————-<br />T E S T S<br />——————————————————-<br />Running com.webcontext.test.unit.libs.zelibraririe.UserServiceTest<br />Tests run: 4, Failures: 0, Errors: 0, Skipped: 0, Time elapsed: 0.067 sec
<br />Results :
<br />Tests run: 4, Failures: 0, Errors: 0, Skipped: 0
<br />[INFO] ————————————————————————<br />[INFO] BUILD SUCCESS<br />[INFO] ————————————————————————<br />[INFO] Total time: 2.198s<br />[INFO] Finished at: Tue Apr 15 02:49:08 CEST 2014<br />[INFO] Final Memory: 16M/174M<br />[INFO] ————————————————————————
<br />p. Le projet a bien été compilé et les tests se sont correctement<br />exécutés !
<br />p. Maven a procédé à la compilation de nos sources, et a vérifié<br />le projet en jouant les tests unitaires.
<br />p. Nous irons encore plus loin dans la suite de l’article en<br />expliquant ce que devient notre projet après compilation et test.
<br />h2. Et mon Jar dans tout ça ?
<br />p. L’ultime étape de notre article est de générer une archive java<br />contenant notre bibliothèque.
<br />p. Pour cela, nous allons ajouter un nouveau plugin Maven, le plugin de<br />generation du jar (sic): <code>maven-jar-plugin</code> (re sic). Ajoutons donc les lignes suivantes à notre bonne vieille <code>pom.xml</code>, à la suite des autres plugins déjà présents :
<br />bc(xml).. <!-- Configuration du jar --><br /><plugin><br /><groupId>org.apache.maven.plugins</groupId><br /><artifactId>maven-jar-plugin</artifactId><br /><version>2.4</version><br /></plugin>
<br />p. Si vous regarder dans le répertoire <code>target</code> après une construction de votre projet, nous pouvons observer l’apparition d’un <code>JAR</code>. C’est le résultat de la compilation et du packaging réalisé par maven via le plugin JAR:
<br />bc(console).. $ ll target<br />total 40<br />drwxr-xr-x 9 frederic frederic 4096 avril 16 19:14 ./<br />drwxr-xr-x 5 frederic frederic 4096 avril 16 19:14 ../<br />drwxr-xr-x 3 frederic frederic 4096 avril 16 19:14 classes/<br />drwxr-xr-x 3 frederic frederic 4096 avril 16 19:14 generated-sources/<br />drwxr-xr-x 3 frederic frederic 4096 avril 16 19:14 generated-test-sources/<br />drwxr-xr-x 2 frederic frederic 4096 avril 16 19:14 maven-archiver/<br />drwxr-xr-x 3 frederic frederic 4096 avril 16 19:14 maven-status/<br />drwxr-xr-x 2 frederic frederic 4096 avril 16 19:14 surefire-reports/<br />drwxr-xr-x 3 frederic frederic 4096 avril 16 19:14 test-classes/<br /><del>rw-r—r— 1 frederic frederic 2298 avril 16 19:14 zelibrairie-0.0.1-SNAPSHOT.jar
<br />p. Nous avons produit notre logiciel, nous l’avons packagé en JAR. il ne nous reste plus qu’à l’estampiller comme une release.
<br />p. Et bien cela tombe bien, nous pouvons aussi confier cette tâche à Maven. Nous allons réaliser cela à l’aide 3 nouveaux plugins:<br />* <strong>maven-javadoc-plugin</strong> pour produire la<br />documentation au format javadoc de notre API,<br />* <strong>maven-src-plugin</strong> pour livrer les sources<br />avec notre applciation<br />* <strong>maven-release-plugin</strong> pour faire la release<br />et la livraison de cette application sur un dépôt de type maven.
<br />h2. La release !
<br />h3. Documentons, documentons !
<br />p. Commençons par le premier step, à savoir, la documentation de notre librairie.
<br />p. Comme nous l’avons remarqué, tout passant par des plugins, ajoutons notre nouveau plugin au fichier <code>pom.xml</code> de notre projet:
<br />bc. <plugin><br /><groupId>org.apache.maven.plugins</groupId><br /><artifactId>maven-javadoc-plugin</artifactId><br /><version>2.9.1</version><br /></plugin>
<br />p. Relançons la compilation avec une commande que nous connaissons maintenant, mais ajoutons un goal supplémentaire:
<br />bc.. <br />$ mvn clean install javadoc:jar
<br />p. si vous regarder dans le répertoire <code>target</code> , un nouveau jar a fait son apparition :
<br />bc.. $ ll target<br />total 116<br />drwxr-xr-x 12 frederic frederic 4096 avril 16 19:29 ./<br />drwxr-xr-x 5 frederic frederic 4096 avril 16 19:27 ../<br />drwxr-xr-x 4 frederic frederic 4096 avril 16 19:29 apidocs/<br />drwxr-xr-x 3 frederic frederic 4096 avril 16 19:27 classes/<br />drwxr-xr-x 3 frederic frederic 4096 avril 16 19:27 generated-sources/<br />drwxr-xr-x 3 frederic frederic 4096 avril 16 19:27 generated-test-sources/<br />drwxr-xr-x 2 frederic frederic 4096 avril 16 19:28 javadoc-bundle-options/<br />drwxr-xr-x 2 frederic frederic 4096 avril 16 19:27 maven-archiver/<br />drwxr-xr-x 3 frederic frederic 4096 avril 16 19:27 maven-status/<br />drwxr-xr-x 3 frederic frederic 4096 avril 16 19:28 site/<br />drwxr-xr-x 2 frederic frederic 4096 avril 16 19:27 surefire-reports/<br />drwxr-xr-x 3 frederic frederic 4096 avril 16 19:27 test-classes/<br /></del>rw-r—r— 1 frederic frederic 2323 avril 16 19:27 zelibrairie-0.0.1-SNAPSHOT.jar<br /><del>rw-r—r— 1 frederic frederic 64253 avril 16 19:29 zelibrairie-0.0.1-SNAPSHOT-javadoc.jar

<br />p. Le fichier <code>zelibrairie-0.0.1-SNAPSHOT-javadoc.jar</code> a été généré par le plugin javadoc. Ainsi, la documentation est prête.
<br />h3. La source du savoir
<br />p. Tout bon packaging de logiciel doit être accompagné de ses sources.
<br />bc. <plugin><br /><groupId>org.apache.maven.plugins</groupId><br /><artifactId>maven-source-plugin</artifactId><br /><version>2.2.1</version><br /></plugin> 

<br />Nous lancerons de nouveau un appel à <code>mvn</code>:
<br />bc.. $ mvn source:jar

<br />p. Ce qui produira le fichier <code>zelibrairie-0.0.1-SNAPSHOT-sources.jar</code>. Ok, l’étape finale nécessite un peu plus de configuration : la RELEASE !
<br />h3. Relachement du stress
<br />p. La touche finale est la livraison ou delivery, le dernier petit coup de stress avant la fin du projet. Là aussi, Maven va nous donner un bon coup de main avec le plugin <code>maven-release-plugin</code>.
<br />bc. <plugin><br /> <groupId>org.apache.maven.plugins</groupId><br /> <artifactId>maven-release-plugin</artifactId><br /> <version>2.5</version><br /></plugin> 
<br />p. Mais pour que celui-ci soit opérationnel, nous devons indiquer plusieurs choses:
<br /># le repository des sources di projet, a travers lequel il va<br />pouvoir versionner et tagger notre livraison,<br /># comment accèder à ce repository<br /># comment versionner.
<br />p. tout cela est fait à travers l’entrée suivante dan le pom.xml:
<br />bc. <scm><br /> <url>http://github.com/web-context/tutorial-maven.git</url><br /> <connection>scm:git:git@github.com.org:web-context/tutorial-maven.git</connection><br /> <developerConnection>scm:git:git@github.com:web-context/tutorial-maven.git</developerConnection><br /> <tag>${project.version}</tag><br /></scm>
<br />p. où:
<br />* l’<code>url</code> indique le chemin sur le réseau où nous pourrons consulter le repository versioné du projet,<br />* la <code>connection</code> est l’url du dépôt sur lequel les sources sont stockées. C’est sur cette url que le plugin va réaliser les tags de version. elle est de la forme: <code>scm:[git/svm/cvs/hg]:([protocole:port]:)[server]([:port])/[repository]</code> où:<br /><strong>*</strong>protocole* http ou ssh <br /><strong>*</strong>server* Nom du serveur, ou nom DNS du service<br /><strong>*</strong>port* votre serveur ne sert peut-être pas par défaut ur le port 80, mais sur u autre port, par ex: 8080<br /><strong>*</strong>repository* le nom du dépôt sur le serveur. généralement préfixé par le nom d’utilistaur propriétaire du dépôt, ex: web-context/tutorial-maven.git<br />* <code>developperConnection</code> est l’url dans le dépôt de la branche de développement.<br />* <code>tag</code> est le template de marqage des release: ${project.version} permet de récupérer le numéro de version.
<br />p. Pour réaliser la release, nous devons faire les choses en deux étapes:
<br /># Préparer la release, permet de packager dans la bonne version: le versionning <code>0.0.1-SNAPSHOT</code>code&gt; sera remplacé par la version &quot;release&quot;, à savoir <code>0.0.1</code> # Faire la release, c’est a dire pousser les sources et la tagger, en pousser les composants vers le gestionnaire<br />de composant .
<br />h3. Release:prepare
<br />p. Lors de cette étape, Maven va nous demander de confirmer la version à releaser. celle-ci correspond à la version de la balise Projet <code>&lt;version&gt;</code>, soit ici <code>0.0.1-SNAPSHOT</code>, version de travail, ce qui donne lieu à la release <code>0.0.1</code>.

<br />bc.. $ mvn release:prepare
<br />p. Si nous regardons du côté de notre repository GIT:
<br />&lt;figure&gt;<br />&lt;figcaption&gt;<br /><a href="http://mcgivrer.files.wordpress.com/2014/04/github-release-tag.png"><img style="width:600px" src="http://mcgivrer.files.wordpress.com/2014/04/github-release-tag.png"/></a><br />&lt;figcaption&gt;Release:Prepare push tag to code repository accordding to <code>&lt;tag&gt;</code> format.&lt;/figcaption&gt;<br />&lt;/figure&gt;
<br />p. A cette étape, la release est prête a être lancée.
<br />h3. Release:perform
<br />p. La réalisation de la release implique que d’autrtes éléments de configuration soient apportés, en l’occurrence, la définition du dépôt cible de la release.

<br />&lt;dl&gt;<br />&lt;dt&gt;Repository Maven&lt;/dt&gt;<br />&lt;dd&gt;Un répository maven est un dépôt destiné à contenir l’ensemble des versions d’un produit, avec ses dépendances, sa documentation et ses sources. Le dépot est accédé par maven lui-même lors des phases de calculs des dépendances d’un logiciel afin de les mettre à disposition du compilateur d’une part, puis de les glisser dans le packaging final, suivat les besoins exprimés dans le fichier <code>pom.xml</code>&lt;/dd&gt;<br />&lt;/dl&gt;
<br />p. A la fin de la release <strong>0.0.1</strong>, le logiciel a été versionné en <strong>0.0.2-SNAPSHOT</strong>, prêt pour recevoir le développement de la prochaine release

<br />p. Si nous regardons dans notre dépôt d’artefact , nous pourrons voir que les jar du logiciel, des sources et de la javadoc en version 0.0.1 ont été poussés tous les trois.

<br />p=. <a href="http://mcgivrer.files.wordpress.com/2014/04/nexus-release-0-0-1.png"><img src="http://mcgivrer.files.wordpress.com/2014/04/nexus-release-0-0-1.png" alt="" />(Screenshot Nexus version 0.0.1)</a>
<br />p=. Screenshot Nexus version 0.0.1

<br />bq. <strong>Note</strong><br />Attention, les modifications doivent<br />toutes avoir été commitées sinon, la préparation de la<br />release est refusée.
<br /><em>To be continued …</em>
<br />DRAFT DRAFT DRAFT DRAFT DRAFT DRAFT DRAFT DRAFT DRAFT DRAFT DRAFT DRAFT DRAFT DRAFT DRAFT DRAFT 
<br />h1. Maven</del> Step 3 : Une application Web a tester
<br />Mantenant qe nous avons les bases de réalisation d’un logicel Java, compilé, testé unitairement, , documenté, packagé et publié via Maven, nous pouvons passer à l’étape suivante: appliquer cette recette à une applicaiton Web.
<br />h2. Quelques pré-requis
<br />Afin de monter à bord facilement, il est indispensable d’avoir quelques bases relative la conception et au fonctionnement d’application web aujourd’hui standard; à savoir, comprendre l’approche dite”orientée REST“:http://fr.wikipedia.org/wiki/Representational_State_Transfer, et avoir déjà manipulé un serveur d’application Java web.<br />L’idéal serait aussi d’avoir quelques notions autour des EJB et autres composants exotiques du monde JavaEE. Nous considererons que ces notions sont connues et sues.
<br />Nous partirons donc sur une approche JavaEE 6, avec un EJB, une persistence en JPA 2.0 et un web service REST.
<br />Le tout dans un serveur d’application JBoss.
<br />Nous choisirons volontairement”JBoss“:http://www.jboss.org pour sa facilité d’intégration avec la chaine d’outils de test unitaire gravitant autour de”Arquillian“:http://www.arquillian.org. Outil que nous utiliserons en deuxième partie de cet article pour tester certains composants de notre application.
<br />h2. Platforme ? comme les chaussures vous voulez dire ?
<br />Non, par platforme, nous entendons plateforme de développement.
<br />La plateforme de développement est constituée du JDK 1.7 et du serveur JBOSS AS 7.
<br />Sous Linux l’installation de JBoss est assez simple. Référons nous, au besoin, à la”doc en ligne“:https://docs.jboss.org/author/display/AS7/Installing+and+starting+JBoss+AS+on+Linux,+Unix+or+Mac+OS+X.
<br />Comme d’habitude, nous installerons jdk via <code>apt-get</code> et serveur dans <code>/opt/tools/java/servers/jbos/as7</code> en respectant les préconisations de l’article”Set a Java Development workstation on Ubuntu“:http://mcgivrer.wordpress.com/2012/11/13/set-a-java-development-workstation-on-ubuntu/.
<br />OK, je crois que nous pouvons maintenant nous (re)lancer à la conquète de Maven.
<br />h2. Maven et le chic web
<br />h3. l’éternel JUnit
<br />Si nous testons des composants non liés à la plateforme JavaEE, comme dans notre article précédent, seul”JUnit“:http://www.junit.org est necessaire.<br />Mais dans le cas où nous devons apporter quelques implementation des spécifications JavaEE, la mise en euvre de test se complique tout de suite.
<br />Nous pouvons arriver à résoudre certains problème lié à JPA via des instanciations sauvages sans profiter de <code>CDI</code> ou de <code>PersistenceContext</code>, mais pour les EJB, c’est tout de suite plus chaud. 
<br />Aussi, nous allons mettre en oeuvre l’outil ultime de test dans le chapitre suivant: <strong>Arquillian</strong>.
<br />h3. Environnement de test
<br />L’environnement de test est aussi le contexte d’exécution de votre code de test unitaire.
<br />bc(java). <code>FixMethodOrder(MethodSorters.NAME_ASCENDING)
public class UserDAOTest(){
    </code>PersistenceContext(unitName=”restwebapp“)<br /> EntityManager em;<br /> …<br /> <code>Test
    public void test_1_insertUser(){
        User user = new User(&quot;prenom&quot;,&quot;nom&quot;,&quot;email</code>domaine.com”);<br /> em.persist(user);<br /> assertTrue(“User has not been saved”,user.getId()!=null);<br /> }<br /> …<br />}</p>
<p>afin que notre annotation fonctionne, nous devons fournir un context à notre test unitaire. C’est ce que va nous apporter Arquillian.</p>
<p>Ajoutons donc cette dépendnce maven à notre <code>pom.xml</code>:</p>
<p>bc(xml).</p>
<!-- 
   Specific dependency management block 
   for arquillian 
-->
<p><dependencyManagement><br /> <dependencies><br /> <dependency><br /> <groupId>org.jboss.arquillian</groupId><br /> <artifactId>arquillian-bom</artifactId><br /> <version>1.1.4.Final</version><br /> <scope>import</scope><br /> <type>pom</type><br /> </dependency><br /> <dependency><br /> <groupId>org.jboss.arquillian.extension</groupId><br /> <artifactId>arquillian-drone-bom</artifactId><br /> <version>1.3.0.Final</version><br /> <type>pom</type><br /> <scope>import</scope><br /> </dependency><br /> </dependencies><br /></dependencyManagement></p>
<p>Il faut alors déclarer les dépendances nécessaires :</p>
<p>bc(xml).</p>
<!--
   Arquillian
-->
<p><dependency><br /> <groupId>org.jboss.arquillian.junit</groupId><br /> <artifactId>arquillian-junit-container</artifactId><br /> <scope>test</scope><br /></dependency></p>
<p>Une fois les dépendances clairement indiquiées, on peut psr à la partie code de notre context de test d’execution. en haut de votre classe JUnit de test, il va falloir indiquer une annotation <strong><code>RunWith(Arquillian.class)* permettant de spécifier à Arquillian qu'il faut batir un context pour cette classe de test.

Il faut ensuite créer une méthde donnant les caractéristiques du packaging à construire pour cette classe de test. vous devrez indiquer les classes dépendances et certains fichiers indispensables à l'execution de JavaEE, comme le fichier </code>beans.xml<code>, ou le fichier </code>persistence.xml@ dans notre cas.
<br />Afin de tester une resource de type persistence, il faut créer une archive Java.
<br />bc.. <code>RunWith(Arquillian.class)
</code>FixMethodOrder<br />public class UserEJBTest {
<br /> <code>PersistenceContext(unitName = &quot;defaultPersistenceUnit&quot;)
  private UserDAO users;

  </code>Deployment<br /> public static JavaArchive createArchiveAndDeploy {<br /> return ShrinkWrap<br /> .create<br /> .addClasses<br /> .addAsResource<br /> .addAsManifestResource;<br /> }
<br /> @Test<br /> public void testFindAll {<br /> List<User> list = users.findAll;<br /> assertTrue &gt; 0);<br /> }<br />}
<br />h3. Arquillian, le sauveur
<br />h2. Tests Unitaires
<br />TODO

<br />h2. Tests d’integration
<br />TODO
<br />h2. Tests End-2-End
<br />TODO

<br />h3. One step beyond
<br />Un serveur embarqué dans l’application, grâce à Maven, c’est possible !
<br /></strong> JBoss</p>
<p>TODO</p>
<ul>
<li>GlassFish</li>
</ul>
<p>TODO</p>
<ul>
<li>TomEE</li>
</ul>
<p>TODO</p>
<ul>
<li>Jetty </li>
</ul>
<p>TODO</p>
