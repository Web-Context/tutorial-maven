<!DOCTYPE html>
<html lang="en">
<head>
	<meta charset="utf-8">
	<title>Maven : step 2 - Dans le gras du sujet</title>
	<link rel="stylesheet" href="illustrations/doc.css" />
</head>
<body>
<div class="markdown-body">
	<h1>Dans le gras du sujet</h1>

	Il faut bien avouer que le premier article était TRES succinct. Je vous
	propose d'aborder plus sérieusement le sujet.

	<h2>Gooooooaaal !</h2>

	Commençons par le début: les "goals" (non, rien à voir avec le foot,
	quoique ... )  J'ai évoqué dans la première partie le fait que Maven
	couvrait toutes les phases de la production logicielle. Et bien c'est
	exactement le cas. Laissez moi illustrer (avec un peu d'inspiration du
	livre référence "
	<a title="Aller sur le site Amazon.com pour contempler ce bô livre"
		href="http://www.amazon.com/gp/product/0596517335" target="_blank">Maven:
		the definitive guide</a>", je l'avoue) l'exemple d'un projet java
	consistant à créer une librairie livrable sous forme de jar. Commençons
	par le début, appelons notre librairie ZeLibraire, publiée par moi même
	et qui, malencontreusement ne sert a rien d'autre que d'être un
	exemple par pour cette série d'article. Nous allons donc produire un
	beau logiciel à l'aide de maven. pour cela, nous devrons, compiler,
	gérer des dépendances, faire des tests (par là j'entends les jouer en
	automatique) et enfin, si tout cela fonctionne, nous pourrons le
	packager sous la forme d'un JAR. Ensuite nous verrons que, afin de
	livrer cette librairie de façon propre et élégante, nous pourrons
	assemble sources, documentation et jar de façon très propre (limite
	professionnel oserais-je, et cela tombe bien, c'est à cela que
	Maven sert). Voila un premier schéma (chouette hein ?) qui explique les
	principales phases que nous allons activer pour notre projet
	Zelibrairie.

	<a href="http://mcgivrer.files.wordpress.com/2014/04/maven-phases-vs-goals.png"><img
		class="aligncenter wp-image-790 size-large"
		src="http://mcgivrer.files.wordpress.com/2014/04/maven-phases-vs-goals.png?w=750"
		alt="maven-phases-vs-goals" width="750" height="562" /></a>
		
	Bon, un peu	d'explication:  sur la gauche, en bleu, les phases gérées par Maven,
	sur la droite, les "Goals" activables correspondants. Ok, nous voilà
	bien avancés, nous ne savons toujours pas ce qu'est un "goal". Un goal
	est en fait une action que l'on peut lancer depuis la ligne de commande
	mvn.  (NDR: Ah ben quand même, il a lâcher le morceau :). Bon, donc
	maintenant, on commence à entrevoir quelques bribes de choses
	compréhensible.

	<h2>A l'attaque des pom's</h2>

	Si je veux commencer à créer mon projet , voilà à quoi ressemble les
	premières lignes de mon fichier de projet maven: file:
	<strong>pom.xml</strong>
	<pre class="xml">&lt;project xmlns="http://maven.apache.org/POM/4.0.0" 
  xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" 
  xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 
    http://maven.apache.org/xsd/maven-4.0.0.xsd"&gt;
  &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt;
  &lt;groupId&gt;com.webcontext.apps&lt;/groupId&gt;
  &lt;artifactId&gt;zelibrairie&lt;/artifactId&gt;
  &lt;version&gt;0.0.1-SNAPSHOT&lt;/version&gt;
  &lt;packaging&gt;jar&lt;/packaging&gt;
  &lt;name&gt;ZeLibrairie&lt;/name&gt;
  &lt;description&gt;A demonstration librabry project to illustrate apache maven usage. &lt;/description&gt;
  &lt;url&gt;http://www.bitbucket.org/webcontext/zelibrairie&lt;/url&gt;
  &lt;organization&gt;
    &lt;name&gt;WebContext&lt;/name&gt;
    &lt;url&gt;http://www.web-context.com/&lt;/url&gt;
  &lt;/organization&gt;
&lt;/project&gt;
</pre>
	Nous avons maintenant indiqué que le projet s'appellerait
	<code>Zelibrairie</code>
	, que le nom maven du projet serait
	<code>zelibrairie</code>
	(artifactId), qu'il serait publié sous le groupe
	<code>com.webcontext.apps</code>
	(groupId). On trouve également une
	<code>version</code>
	du logiciel qui servicra a suivre la vie du dit logiciel. on trouve
	également des champs
	<code>description</code>
	et
	<code>organisation</code>
	qui serviront a documenter le projet lorsque celui-ci sera publié sur
	un dépôt officiel Maven (que nous découvrirons dans la phase de
	release, donc plus tard, dans un prochain article).


	<h2>Super Structure</h2>

	D'ailleurs, je n'ai pas expliqué la structure d'un projet dans les
	détails. Commençons par créer notre répertoire de travail :
	<pre>$ mkdir zelibrairie
$ cd zelibrairie
</pre>
	Ensuite, nous devons créer la struture du projet:
	<pre>$ mkdir -P zelibrairie/src/main/java
$ mkdir -P zelibrairie/src/test/java
</pre>
	et ensuite, à l'aide de votre éditeur de code préféré, créé le fichier
	pom.xml en copiant le contenu de l'exemple précédemment indiqué. vous
	devriez obtenir le structure ci-dessous:
	<pre class="diagram">zelibrairie      # répertoire de base du projet
  |_ src              # sources du projet découpées en deux groupes
  |  |_ main          # les sources a proprement parlé du code du projet
  |  |  |_ java       # - les classes java dans leurs packages
  |  |_ test          # le code des tests unitaires, intégration et E2E.
  |  |  |_ java       # - les parties java pour l'exécution de ce tests
  |_ pom.xml          # le fichier de description du projet Maven.
</pre>


	<h2>Léon le nettoyeur</h2>

	Donc, si nous lançons la commande suivante :
	<code>mvn clean</code>

	On obtient alors, la sortie suivante:
	<pre class="console">$ mvn clean
[INFO] Scanning for projects...
[INFO]                                                                         
[INFO] ------------------------------------------------------------------------
[INFO] Building ZeLibraibrie 0.0.1-SNAPSHOT
[INFO] ------------------------------------------------------------------------
[INFO] 
[INFO] --- maven-clean-plugin:2.5:clean (default-clean) @ zelibrairie ---
[INFO] ------------------------------------------------------------------------
[INFO] BUILD SUCCESS
[INFO] ------------------------------------------------------------------------
[INFO] Total time: 0.299s
[INFO] Finished at: Mon Apr 14 01:42:37 CEST 2014
[INFO] Final Memory: 5M/108M
[INFO] ------------------------------------------------------------------------
</pre>
	Un répertoire
	<code>target</code>
	sera créé dès que nous exécuterons la commande de compilation; c'est là
	que le résultat du travail sera produit.

	<h3>Compilator, le retour</h3>

	Même sans code, vous pouvez lancer une petite compilation :
	<pre class="console">$ mvn compile
</pre>

	donnant lieu à la sortie console suivante :

	<pre class="console">$ mvn compile
[INFO] Scanning for projects...
[INFO]
[INFO] ------------------------------------------------------------------------
[INFO] Building ZeLibrairie 0.0.1-SNAPSHOT
[INFO] ------------------------------------------------------------------------
Downloading: http://repo.maven.apache.org/maven2/org/apache/maven/plugins/maven-
resources-plugin/2.5/maven-resources-plugin-2.5.pom
...
...
Downloaded: http://repo.maven.apache.org/maven2/org/codehaus/plexus/plexus-compi
ler-javac/1.8.1/plexus-compiler-javac-1.8.1.jar (13 KB at 26.8 KB/sec)
[INFO] Nothing to compile - all classes are up to date
[INFO] ------------------------------------------------------------------------
[INFO] BUILD SUCCESS
[INFO] ------------------------------------------------------------------------
[INFO] Total time: 8.715s
[INFO] Finished at: Mon Apr 14 10:52:35 CEST 2014
[INFO] Final Memory: 6M/244M
[INFO] ------------------------------------------------------------------------
</pre>

	Mais comment se fait-il que la compilation d'aucun code produise autant
	de choses ? :) Et bien, cela vient du fait de la nature même de Maven,
	qui est constitué uniquement d'un système de plugins. Ces plugins sont
	activés sur certaines phases du cycle Maven, et s'ils ne sont pas
	disponibles localement (dans un répertoire de cache
	<code>[USERHOME]/.m2/</code>
	), ils sont automatiquement téléchargés, et activés. En lançant pour la
	premier fois la compilation de notre projet, c'est ce qu'il vient de se
	passer. Dans le log des opérations, on peut constater, entre autres, le
	téléchargement d'un plugin du nom de
	<code>plexus-compiler-javac-1.8.1.jar</code>
	: c'est le moteur de compilation de Maven pour les fichiers sources
	java. On peut finalement voir que notre compilation à réussi (le
	contraire eu été inquiétant :) Ok, ajoutons un peu de code pour voir de
	quoi Maven est capable !

	<h2>Les choses sérieuses</h2>

	La structure d'un pom est très importante et elle donne moulte
	information sur un projet. Reprenons le
	<code>pom.xml</code>
	standard et regardons de plus près les différents blocs: 
	
	[caption id="attachment_794" align="aligncenter" width="400"]
	<a
		href="http://mcgivrer.files.wordpress.com/2014/04/maven-pom-xml-full-structure-overview.png"><img
		class="wp-image-794"
		src="http://mcgivrer.files.wordpress.com/2014/04/maven-pom-xml-full-structure-overview.png"
		alt="maven-pom-xml-full-structure-overview" width="400" height="648" /></a>
	Les différents blocs dans le fichier pom.xml de Maven.[/caption] 
	
	
	Après avoir découvert ensemble la partie déclaration administrative, nous
	devons voir de plus près la partie
	<strong>dependencies</strong>. Les "dependencies" sont la déclaration
	des librairies nécessaires à l'exécution de votre programme. Ces
	dépendances se retrouveront sur le "chemin de classe" (oui, c'est
	curieux, le classpath en français). et en fonction du paramètre
	<code>scope</code>
	, la librairie sera présente dans le classpath de compilation, de test,
	ou de runtime. Il est également possible de d&clarer des dépendances
	dites "systèmes", elles seront packagée dans l'application finale,non
	pas depuis le repository (que nous découvrirons et expliquerons plus
	tard) mais depuis un chemin fixe, par exemple
	<code>c:\meslibrairies\monjar.jar</code>
	.

	<h3>les différents scopes</h3>

	<table>
		<tr>
			<th>Scope</th>
			<th>Description</th>
		</tr>
		<tr>
			<td><code>compile</code></td>
			<td>La dépendance sera ajoutée au classpath dans tous les cas</td>
		</tr>
		<tr>
			<td><code>runtime</code></td>
			<td>la dépendance sera package avec l'application mais n'est pas
				nécessaire à la compilation.</td>
		</tr>
		<tr>
			<td><code>test</code></td>
			<td>cette fois, la dépendance sera présente uniquement lors de
				la phase d'execution des tests (voir le graphe plu haut pour revoir
				les phases/goals de maven</td>
		</tr>
		<tr>
			<td><code>system</code></td>
			<td>La dépendance système a la particularité</td>
		</tr>
		<tr>
			<td><code>provided</code></td>
			<td>La dépendance est intégrée au classpath pour la compilation
				mais ne sera pas packagée car réputée fournie par l'environnement
				d'execution de l'application, le conteneur web dans le cas d'une
				application, par exemple.</td>
		</tr>
		<tr>
			<td><code>import</code></td>
			<td>ce scope n'est disponible que pour une dépendance de type <code>pom</code>.
				l'ensemble des dépendances mentionnées dans le pom référencé comme
				dépendances seront portées au classpath et packagée dans
				l'application.
			</td>
		</tr>
	</table>

	Nous disions vouloir construire une premier application, donc ? non ?

	Ajoutons les dépendances de base nécessaire à notre petite code party:
	à savoir l'indispensable logger
	<code>Log4J</code>
	, ainsi que le non moins indispensable
	<code>JUnit</code>
	ce qui nous permettra de jouer avec les fameux scopes et permettra de
	mieux comprendre leur intérêt. Donc, éditons notre fichier POM pour
	ajouter les dites dépendances:

	<pre class="xml">
&lt;project&gt;
  ...
  &lt;groupId&gt;&lt;/groupId&gt;
  &lt;artifactId&gt;&lt;/artifactId&gt;
  &lt;version&gt;&lt;/version&gt;
  ...
  &lt;dependencies&gt;

    &lt;!-- logging capability --&gt;
    &lt;dependency&gt;
      &lt;groupId&gt;log4j&lt;/groupId&gt;
      &lt;artifactId&gt;log4j&lt;/artifactId&gt;
      &lt;version&gt;1.2.17&lt;/version&gt;
    &lt;/dependency&gt;

    &lt;!-- testing capability --&gt;
    &lt;dependency&gt;
      &lt;groupId&gt;junit&lt;/groupId&gt;
      &lt;artifactId&gt;junit&lt;/artifactId&gt;
      &lt;version&gt;4.11&lt;/version&gt;
      &lt;scope&gt;test&lt;/scope&gt;
    &lt;/dependency&gt;

  &lt;/dependencies&gt;
  ...
&lt;/project&gt;
</pre>

	<h3>Configurador del Compeladores</h3>

	Ensuite concentrons nous sur la compilation. Nousouhaitons préciser que
	l'application doit être compilée sur un JDK 1.7 et que nous voulons
	nous assurer que les sources soient bien encodés en UTF-8: c'est le
	plugin maven special
	<code>maven-compiler-plugin</code>
	qui a la charcge de vérifier et activer cela:

	<pre class="xml">  &lt;build&gt;
      &lt;plugins&gt;
        &lt;plugin&gt;
          &lt;groupId&gt;org.apache.maven.plugins&lt;/groupId&gt;
          &lt;artifactId&gt;maven-compiler-plugin&lt;/artifactId&gt;
          &lt;version&gt;3.1&lt;/version&gt;
          &lt;configuration&gt;
            &lt;target&gt;${src.target}&lt;/target&gt;
            &lt;source&gt;${src.source}&lt;/source&gt;
            &lt;encodage&gt;${src.encodage}&lt;/encodage&gt;
          &lt;/configuration&gt;
        &lt;/plugin&gt;
      &lt;/plugins&gt;
  &lt;/build&gt;
</pre>


	Nous utilisons ici une version 3.1 du plugin. nous précisons l'encodage
	des fichiers et le JDK a utiliser.

	<h3>Application à 2 classes</h3>

	OK, créons une ou deux classes (en fait deux) dans le répertoire
	<code>src/main/java</code>
	en respectant biensur le chemin de package
	<code>com.webcontext.libs.zelibrairie</code>
	pour pouvoir faire quelques tests depuis l'autre répertoire
	<code>src/test/java</code>
	: nota: les classes ont été volontairemetn simplifiées dans l'article
	et sont bien complète sur le repository github
	(http://github.com/Web-Context/tutorial-maven ) 1. une entité digne de
	ce nom pour modélisé un User (oh c'est super original, je sais) :

	<p>
		file:
		<code>com.webcontext.libs.zelibrairie.model.User</code>
	</p>

	<pre class="java">public class User{
    public String username;
    public String lastname;
    public String firstname;
    public String email;
    public String password;
    
    public User(){

    }

    /*---- getters &amp; setters ----*/
    ...

  @Override
  public String toString() {
    StringBuilder builder = new StringBuilder();
    builder.append("User [");
    if (username != null)
      builder.append("username=").append(username).append(", ");
    if (email != null)
      builder.append("email=").append(email).append(", ");
    if (firstname != null)
      builder.append("firstname=").append(firstname).append(", ");
    if (lastname != null)
      builder.append("lastname=").append(lastname);
    builder.append("]");
    return builder.toString();
  }

}
</pre>

	2. un service de gestion de ces utilisateurs :

	<p>
		file:
		<code>com.webcontext.libs.zelibrairie.services.UserService</code>
	</p>

	<pre class="java">public class UserService {
  private static Map<String , User> users = new HashMap<String
			, User>();

  public User add(User user) {
    users.put(user.getUsername(), user);
    return user;
  }

  public void add(Collection<User> newUsers) {
    for (User user : newUsers) {
      users.put(user.getUsername(), user);
    }
  }

  public User update(User user) {
    users.put(user.getUsername(), user);
    return user;
  }

  public User delete(User user) {
    users.remove(user.getUsername());
    return user;
  }

  public User findByUsername(String username) {
    return users.get(username);
  }

  public List<User> findAll() {
    List<User> rtusers = (List<User>) users.values();
    return rtusers;
  }

  public int count() {
    return users.size();
  }

}
	</pre>


	<h3>Testator</h3>

	Nos classes applicatives étant prêtes, nous allons nous pencher sur
	notre classe de test du service
	<code>UserService</code>
	, dans le réeprtoir
	<code>src/test/java</code>
	, donc:

	<p>
		file:
		<code>com.webcontext.test.unit.libs.zelibrairie.services.UserService</code>
	</p>

	<pre class="java">@FixMethodOrder(MethodSorters.NAME_ASCENDING)
public class UserServiceTest {

  private static Map<String , User> userstest = new HashMap<String
			, User>();
  private static UserService userService = new UserService();

  @Before
  public void setUp() throws Exception {
    userService = new UserService();
    userstest = new HashMap<String , User>();
    // add some user
    userstest.put("user1", new User("user1", "User", "User1",
        "user1@mail.com", "password"));
    userstest.put("user2", new User("user2", "User", "User2",
        "user2@mail.com", "password"));
    userstest.put("user3", new User("user3", "User", "User3",
        "user3@mail.com", "password"));
    userstest.put("user4", new User("user4", "User", "User4",
        "user4@mail.com", "password"));
  }

  @After
  public void tearDown() throws Exception {
    userService = null;
    userstest = null;
  }

  @Test
  public void test_1_add() {
    User usernew = new User("usernew", "Usernew", "Newuser",
        "new.user@mail.com", "password");
    userService.add(usernew);
    assertEquals("Size of collection is not the right one.", 1,
        userService.count());
  }

  @Test
  public void test_2_AddListUserandFindByUsername() {
    userService.add(userstest.values());
    assertEquals("All users was not inserted !", 5, userService.count());

    User user1 = userService.findByUsername("user1");
    assertTrue("User not found", user1!=null);
    assertEquals("User not the right one.", "User1", user1.getLastname());
  }
  
  @Test
  public void test_3_AddListUserAndDelete() {
    userService.add(userstest.values());
    
    User user1 = userService.findByUsername("user1");
    userService.delete(user1);
    User isUserDeleted = userService.findByUsername("user1");
    assertTrue("User has not bean deleted", isUserDeleted==null);
  }
  @Test
  public void test_4_update() {
    User usernew = new User("usernew", "Usernew", "Newuser",
        "new.user@mail.com", "password");
    userService.add(usernew);
    User last = userService.findByUsername("usernew");
    last.setFirstname("Toto");
    User modified = userService.update(last);
    
    assertEquals("USer was not modified","Toto",modified.getFirstname());
  }

}

	</pre>


	<h2>Test test test !</h2>

	Maintenant, ne faiblissons pas, compilons et testons

	<pre>$ mvn clean test</pre>

	En laçant cette commande, on nettoie le projet, on compile tous les
	sources, en scope
	<code>compile</code>
	et
	<code>test</code>
	. Enfin, les tests Junit sont executés :

	<pre class="console">[INFO] Scanning for projects...
[INFO]                                                                         
[INFO] ------------------------------------------------------------------------
[INFO] Building ZeLibrairie 0.0.1-SNAPSHOT
[INFO] ------------------------------------------------------------------------
[INFO] 
[INFO] --- maven-clean-plugin:2.5:clean (default-clean) @ zelibrairie ---
[INFO] Deleting /home/frederic/Projects/tutorials/tutorial-maven/samples/zelibrairie/target
[INFO] 
[INFO] --- maven-resources-plugin:2.6:resources (default-resources) @ zelibrairie ---
[WARNING] Using platform encoding (UTF-8 actually) to copy filtered resources, i.e. build is platform dependent!
[INFO] skip non existing resourceDirectory /home/frederic/Projects/tutorials/tutorial-maven/samples/zelibrairie/src/main/resources
[INFO] 
[INFO] --- maven-compiler-plugin:3.1:compile (default-compile) @ zelibrairie ---
[INFO] Changes detected - recompiling the module!
[WARNING] File encoding has not been set, using platform encoding UTF-8, i.e. build is platform dependent!
[INFO] Compiling 2 source files to /home/frederic/Projects/tutorials/tutorial-maven/samples/zelibrairie/target/classes
[INFO] 
[INFO] --- maven-resources-plugin:2.6:testResources (default-testResources) @ zelibrairie ---
[WARNING] Using platform encoding (UTF-8 actually) to copy filtered resources, i.e. build is platform dependent!
[INFO] skip non existing resourceDirectory /home/frederic/Projects/tutorials/tutorial-maven/samples/zelibrairie/src/test/resources
[INFO] 
[INFO] --- maven-compiler-plugin:3.1:testCompile (default-testCompile) @ zelibrairie ---
[INFO] Changes detected - recompiling the module!
[WARNING] File encoding has not been set, using platform encoding UTF-8, i.e. build is platform dependent!
[INFO] Compiling 1 source file to /home/frederic/Projects/tutorials/tutorial-maven/samples/zelibrairie/target/test-classes
[INFO] 
[INFO] --- maven-surefire-plugin:2.12.4:test (default-test) @ zelibrairie ---
[INFO] Surefire report directory: /home/frederic/Projects/tutorials/tutorial-maven/samples/zelibrairie/target/surefire-reports

-------------------------------------------------------
 T E S T S
-------------------------------------------------------
Running com.webcontext.test.unit.libs.zelibraririe.UserServiceTest
Tests run: 4, Failures: 0, Errors: 0, Skipped: 0, Time elapsed: 0.067 sec

Results :

Tests run: 4, Failures: 0, Errors: 0, Skipped: 0

[INFO] ------------------------------------------------------------------------
[INFO] BUILD SUCCESS
[INFO] ------------------------------------------------------------------------
[INFO] Total time: 2.198s
[INFO] Finished at: Tue Apr 15 02:49:08 CEST 2014
[INFO] Final Memory: 16M/174M
[INFO] ------------------------------------------------------------------------

</pre>

	Vous pouvez voir que le projet a bien été compilé et que les tests se
	sont correctement exécutés ! Voila, maven a procédé à la compilation de
	nos sources, et a vérifié celui-ci en jouant les tests unitaires. Nous
	irons encore plus loin dans le prochain article en expliquant ce que
	devient notre projet après compilation et test.

	<h2>Et mon Jar dans tout ça ?</h2>

	L'ultime étape de notre article est de générer une archive java
	contenant notre bibliothèque. ur cela, nous allons ajouter un nouveau
	plugin Maven, le plugin de generation du jar (sic):
	<code>maven-jar-plugin</code>
	(re sic). Ajoutons donc les lignes suivantes à notre bonne vieille
	<code>pom.xml</code>
	, à la suite des autres plugins déjà présents :

	<pre class="xml">&lt;!-- Configuration du jar --&gt;
&lt;plugin&gt;
	&lt;groupId&gt;org.apache.maven.plugins&lt;/groupId&gt;
	&lt;artifactId&gt;maven-jar-plugin&lt;/artifactId&gt;
	&lt;version&gt;2.4&lt;/version&gt;
&lt;/plugin&gt;
</pre>

Si vous regarder dans le répertoire <code>target</code> après une construction de votre projet, nous pouvons observer 
l'apparition d'un <code>JAR</code>. C'est le résultat de la compilation et du packaging réalisé par maven et le plugin JAR: 

<pre class="console">$ ll target
total 40
drwxr-xr-x 9 frederic frederic 4096 avril 16 19:14 ./
drwxr-xr-x 5 frederic frederic 4096 avril 16 19:14 ../
drwxr-xr-x 3 frederic frederic 4096 avril 16 19:14 classes/
drwxr-xr-x 3 frederic frederic 4096 avril 16 19:14 generated-sources/
drwxr-xr-x 3 frederic frederic 4096 avril 16 19:14 generated-test-sources/
drwxr-xr-x 2 frederic frederic 4096 avril 16 19:14 maven-archiver/
drwxr-xr-x 3 frederic frederic 4096 avril 16 19:14 maven-status/
drwxr-xr-x 2 frederic frederic 4096 avril 16 19:14 surefire-reports/
drwxr-xr-x 3 frederic frederic 4096 avril 16 19:14 test-classes/
-rw-r--r-- 1 frederic frederic 2298 avril 16 19:14 zelibrairie-0.0.1-SNAPSHOT.jar
</pre>

Nous avons produit notre logiciel, nous l'avons packagé en JAR. il ne nous reste plus qu'à l'estampiller comme une release.

Et bien cela tombe bien, nous pouvons aussi confier cette tâche à Maven.

Nous allons réaliser cela à l'aide 3 nouveaux plugins:

<ul>
	<li><code>maven-javadoc-plugin</code> pour produire la documentation au format javadoc de notre API,</li>
	<li><code>maven-src-plugin</code> pour livrer les sources avec notre applciation</li>
	<li><code>maven-javadoc-plugin</code> pour faire la release et la livraison de cette application sur un dépôt de type maven.</li>
</ul> 


<h2>La release !</h2>

<h3>Documentons, documentons !</h3>

Commençons par le premier step, à savoir, la documentation de notre librairie. Comme nous l'avons remarqué tout 
passant par des plugin, ajoutons notre nouveau plugin au fichier <code>pom.xml</code> de notre projet:

<pre class="xml">
	&lt;plugin&gt;
		&lt;groupId&gt;org.apache.maven.plugins&lt;/groupId&gt;
		&lt;artifactId&gt;maven-javadoc-plugin&lt;/artifactId&gt;
		&lt;version&gt;2.9.1&lt;/version&gt;
	&lt;/plugin&gt;			
</pre>

Relançons la compilation avec une commande que nous connaissons maintenant, mais ajoutons un goal supplémentaire:

<pre class="console">
$ mvn clean install javadoc:jar
</pre>


si vous regarder dans le répertoire <code>target</code>, un nouveau jar a fait son apparition :
<pre class="console">$ ll target
total 116
drwxr-xr-x 12 frederic frederic  4096 avril 16 19:29 ./
drwxr-xr-x  5 frederic frederic  4096 avril 16 19:27 ../
drwxr-xr-x  4 frederic frederic  4096 avril 16 19:29 apidocs/
drwxr-xr-x  3 frederic frederic  4096 avril 16 19:27 classes/
drwxr-xr-x  3 frederic frederic  4096 avril 16 19:27 generated-sources/
drwxr-xr-x  3 frederic frederic  4096 avril 16 19:27 generated-test-sources/
drwxr-xr-x  2 frederic frederic  4096 avril 16 19:28 javadoc-bundle-options/
drwxr-xr-x  2 frederic frederic  4096 avril 16 19:27 maven-archiver/
drwxr-xr-x  3 frederic frederic  4096 avril 16 19:27 maven-status/
drwxr-xr-x  3 frederic frederic  4096 avril 16 19:28 site/
drwxr-xr-x  2 frederic frederic  4096 avril 16 19:27 surefire-reports/
drwxr-xr-x  3 frederic frederic  4096 avril 16 19:27 test-classes/
-rw-r--r--  1 frederic frederic  2323 avril 16 19:27 zelibrairie-0.0.1-SNAPSHOT.jar
-rw-r--r--  1 frederic frederic 64253 avril 16 19:29 zelibrairie-0.0.1-SNAPSHOT-javadoc.jar
</pre>

Le fichier <code>zelibrairie-0.0.1-SNAPSHOT-javadoc.jar</code> a été généré par le plugin javadoc. 
Ainsi, la documentation est prête.

<h3>La source du savoir</h3>

Tout bon packaging de logiciel doit être accompagné de ses sources.

<pre class="xml">
	&lt;plugin&gt;
		&lt;groupId&gt;org.apache.maven.plugins&lt;/groupId&gt;
		&lt;artifactId&gt;maven-source-plugin&lt;/artifactId&gt;
		&lt;version&gt;2.2.1&lt;/version&gt;
	&lt;/plugin&gt;			
</pre>

a lancer avec encore une fois un appel à <code>mvn</code>:

<pre class="console">$ mvn source:jar
</pre>

Ce qui produira le fichier <code>zelibrairie-0.0.1-SNAPSHOT-javadoc.jar</code>.


Ok, l'étape finale nécessite un peu plus de configuration : la RELEASE !

<h3>Relachement du stress</h3>

La touche finale est la livraison ou delivery, le dernier petit coup de stress avant la fin du projet.

Là aussi, Maven va nous donner un bon coup de main avec le plugin <code>maven-release-plugin</code>.

<pre class="xml">
	&lt;plugin&gt;
		&lt;groupId&gt;org.apache.maven.plugins&lt;/groupId&gt;
		&lt;artifactId&gt;maven-release-plugin&lt;/artifactId&gt;
		&lt;version&gt;2.5&lt;/version&gt;
	&lt;/plugin&gt;			
</pre>


Mais pour que celui-ci soit opérationnel, nous devons indiquer plusieurs choses:

1. le repository des sources di projet, a travers lequel il va pouvoir versionner et tagger notre livraison,
2. comment accèder à ce repository
3. comment versionner.

tout cela est fait à travers l'entrée suivante dan le pom.xml:

<pre class="xml">
	&lt;scm&gt;
		&lt;url&gt;http://bitbucket.org/webcontext/tutorial-maven.git&lt;/url&gt;
		&lt;connection&gt;scm:git:git@bitbucket.org:webcontext/tutorial-maven.git&lt;/connection&gt;
		&lt;developerConnection&gt;scm:git:git@bitbucket.org:webcontext/tutorial-maven.git&lt;/developerConnection&gt;
		&lt;tag&gt;${project.version}&lt;/tag&gt;
	&lt;/scm&gt;
</pre> 

où:
<ul>
<li>l'<code>url</code> indique le chemin sur le net où l'on peut consulter le repository versioné du projet,</li>
<li>la <code>connection</code> est l'url du dépôt sur lequel les sources sont stockées. c'est sur cette url que 
le plugin va réaliser les tags de version.</li>
<li><code>developperConnection</code> est l'url dans le dépôt de la branche de développement.</li>
<li><code>tag</code> est le template de marqage des release: ${project.version} permet de récupérer le numéro 
de version</li>
</ul>
 
pour réaliser la release, nous devons faire les chose en deux étapes:

Préparer la release, permet de packager dans la bonne version: le versionning <code>0.0.1-SNAPSHOT</code>code> 
sera remplacé par la version "release", à savoir <code>0.0.1</code>.
	<em>To be continued ...</em>
	</div>
</body>
</html>
